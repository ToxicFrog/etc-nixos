#!/usr/bin/env bash

: << =cut

=head1 NAME

http__onhub -- plugin to scrape status information from a Google OnHub

=head1 CONFIGURATION

These are the default settings:

[ssh_host.tld_uptime]
  env.onhub_address onhub.here

=head1 AUTHOR

Written by B. Kelly, based on onhub API documentation by Marcus Olsson at
https://github.com/olssonm/google-wifi-api

=head1 LICENSE

MIT

=head1 MAGIC MARKERS

 #%# family=auto
 #%# capabilities=autoconf

=cut

# source $MUNIN_LIBDIR/plugins/plugin.sh

shopt -s lastpipe

### settings ###

myname="$(basename $0)"
host_name="$(echo "$myname" | cut -d_ -f2)"
onhub_address="${onhub_address:=onhub.here}"

if [[ "$1" == "autoconf" ]]; then
  if curl -sf "http://${onhub_address}/api/v1/welcome-mat" >/dev/null; then
    echo yes
  else
    echo "no (could not access http://${onhub_address}/api/v1/welcome-mat)"
  fi
  exit 0
fi

### helper functions used by config ###

STATEFILE="/tmp/$onhub_address.state"
STAMPFILE="/tmp/$onhub_address.stamp"

# output the contents of the onhub statefile, fetching it first if stale
# used by both config (to figure out some dimensions) and fetch
function report {
  touch -d "3 minutes ago" "$STAMPFILE"
  if [[ ! ( -e $STATEFILE ) || ( $STATEFILE -ot $STAMPFILE ) ]]; then
    # Probe the onhub.
    # This is very expensive (10+ seconds), so we only do it if the old state
    # is missing or more than two minutes old.
    curl -s -f http://onhub.here/api/v1/diagnostic-report \
      | zcat > "$STATEFILE"
  fi
  rm "$STAMPFILE"

  cat "$STATEFILE" | strings -n 8 -w
}

# dimension name title fields...
# e.g dimension recv rx draw:AREA type:DERIVE min:0
function dimension {
  name="$1"
  echo "$name.label $2"
  shift 2
  while [[ "$1" ]]; do
    local k="${1%:*}"
    local v="${1#*:}"
    if [[ $k == cdef ]]; then v="$name,$v"; fi
    echo "$name.$k $v"
    shift
  done
}

# TODO map MAC address to hostname or IP
function wifi_strength_dimensions {
  report | sed -n -E '
    /^Station /,/connected time:/ {
      /^Station / { s,Station ([0-9a-f]+) .*,\1,; p; }
    }' | while read mac; do
      dimension "wifi_power_$mac" "$mac" draw:LINE2 type:GAUGE
    done
}

### config implementation ###

if [[ "$1" = "config" ]]; then
  cat <<EOF
host_name $host_name
multigraph onhub_network
graph_title Network size
graph_category network
graph_vlabel number of hosts
graph_info Information about the number of hosts on the network managed by the OnHub.
$(dimension arp_count "ARP table size" type:GAUGE draw:LINE2)
arp_count.info The size of the ARP table, i.e. the number of distinct devices the OnHub has seen on the network, whether or not it gave them an IP address itself.
$(dimension dhcp_count "DHCP lease count" type:GAUGE draw:LINE2)
dhcp_count.info The number of devices the OnHub has given IP addresses to, whether or not they're currently connected.
$(dimension peer_count "DHCP client count" type:GAUGE draw:LINE2)
peer_count.info The number of currently connected peers that the OnHub gave addresses to via DHCP.

multigraph onhub_speed
graph_title WAN speed
graph_category network
graph_vlabel upstream (-) / downstream (+) speed
graph_info This is the maximum WAN speed as measured by the OnHub during its most recent automatic probe.
graph_args --base 1000
$(dimension downstream Downlink draw:AREA type:GAUGE cdef:8,*)
$(dimension upstream Uplink draw:AREA type:GAUGE cdef:8,*)

multigraph onhub_traffic_wan
graph_title Network traffic (WAN)
graph_category network
graph_vlabel bytes per \${graph_period}
graph_info Network traffic on the WAN interface.
graph_args --base 1000
$(dimension wan_recv RX draw:LINE2 type:DERIVE min:0 cdef:256,/)
$(dimension wan_sent TX draw:LINE2 type:DERIVE min:0 cdef:256,/)

multigraph onhub_traffic_lan
graph_title Network traffic (LAN)
graph_category network
graph_vlabel bytes per \${graph_period}
graph_info Network traffic on all the LAN interfaces (cat5, 2.4GHz wifi, and 5GHz wifi) combined.
graph_args --base 1000
$(dimension lan_recv RX draw:LINE2 type:DERIVE min:0 cdef:256,/)
$(dimension lan_sent TX draw:LINE2 type:DERIVE min:0 cdef:256,/)

multigraph onhub_wifi_strength
graph_title Wifi signal strength
graph_category network
graph_vlabel dBm
graph_info Signal strength (in decibel-milliwatts) of connected WiFi peers. If a peer is listed in the legend but has no data for a given time range, it was not connected during that time but had been seen recently by the AP.
graph_args --base 1000
$(wifi_strength_dimensions)
EOF

# upstream.graph yes
# downstream.negative upstream
# lan_sent.graph no
# wan_sent.graph no
# lan_recv.negative lan_sent
# wan_recv.negative wan_sent
  exit 0
fi

### helper functions for fetch ###

function arp-count {
  report | sed -E -n '/\/proc\/net\/arp/,/^$/ p;' | grep br-lan | wc -l
}

function dhcp-count {
  report | fgrep -a "dhcp_lease " | wc -l
}

function peer-count {
  report | fgrep -a "connected: true" | wc -l
}

function speedtest {
  report | fgrep -a "$1_speed_bytes_per_second:" | cut -d: -f2
}

function ifstat {
  report \
    | sed -E -n '/ip -s -d addr/,/^$/ p;' \
    | sed -E -n "/^[0-9]: $1: /,/^[0-9]/ p;" \
    | sed -E -n "/^    $2: bytes/ { n; p; q; }" \
    | read bytes packets errors dropped _
  # RX and TX bytes values, despite saying "bytes" in the dump, are (a) in hex
  # and (b) actually (bytes * 256). At least, the values are 256 times higher
  # than the same network traffic reported by the other end.
  # We use a cdef to fix this.
  printf "%d" 0x$bytes
}

function wifi_strength_values {
  report | sed -n -E '
    /^Station /,/connected time:/ {
      /^Station / { s,Station ([0-9a-f]+) .*,\1,; p; }
      /signal: / { s,signal:[[:space:]]+(-?[0-9]+) dBm,\1,; p; }
    }' | while read mac; do
      read dBm
      echo "wifi_power_$mac.value $dBm"
    done
}

### fetch implementation ###

cat <<EOF
multigraph onhub_network
arp_count.value $(arp-count)
dhcp_count.value $(dhcp-count)
peer_count.value $(peer-count)
multigraph onhub_speed
upstream.value $(speedtest upload)
downstream.value $(speedtest download)
multigraph onhub_traffic
lan_sent.value $(ifstat br-lan TX)
lan_recv.value $(ifstat br-lan RX)
wan_sent.value $(ifstat wan0 TX)
wan_recv.value $(ifstat wan0 RX)
$(wifi_strength_values)
EOF

  # graphs:
  # size of ARP table: /proc/net/arp
  # number of DHCP leases: dhcp_lease { ... }
  #   both also let us match up IPs to MACs
  # bandwidth and connection strength of wifi clients: "station dump"
  #   uses MACs
  #   there does not appear to be an equivalent for wired clients
  # network connection status:
  #   infra_state.wan_speed_test_results
  #   network_service_state.wan_state
  # DHCP clients:
  #   station_state_update.station_info.*
  #   contains mDNS name, DHCP hostname, and IP address
  #   connected: true if still connected
  #   wireless: true if wifi
  #   not everything has names
  #   lets us map name to IP (if any names are specified)
  # per-interface bandwidth:
  #   ip -s -d addr
  #   wan0 is the WAN
  #   lan0 is the cat5
  #   wlan-2400mhz and wlan-5000mhz are the two bands of wifi
  #   br-lan combines lan0 and the wifi interfaces

# This requires us to probe the onhub to run "configure" which is not great
# graph_title Per-device wifi traffic
# graph_category network
# graph_args --base 1000
# graph_vlabel bits sent (-) / received (+) by peer
# $(output_wifi_bandwidth_labels)
# send_$name.label $name
# send_$name.graph no
# send_$name.type DERIVE
# send_$name.min 0
# send_$name.cdef wifi_send_$name,8,*
# recv_$name.label $name
# recv_$name.draw AREASTACK
# recv_$name.type DERIVE
# recv_$name.min 0
# recv_$name.cdef wifi_recv_$name,8,*
# recv_$name.negative send_$name
# graph_title Wifi signal strength
# ...similar to above...
